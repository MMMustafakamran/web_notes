# Express JS Study Notes

## Introduction to Express JS

Express is described as "a minimal and flexible Node.js web application framework, providing a robust set of features for building single and multipage and hybrid web applications."

### Key Characteristics

**Minimal**
- Provides the minimal layer between your brain and the server
- Gets in your way less, allowing full expression of your ideas
- Still robust with enough useful features

**Flexible**
- Extensible framework
- Add different parts of Express functionality as needed
- Replace what doesn't meet your needs
- Add what you need when you need it (opposite of bloated frameworks)

### Basic Information
- Initially released in November 2010
- Current stable version: 5.0.0 (2024-09-10)
- **Unopinionated**: You can insert compatible middleware in any order, structure app in one/many files, use any directory structure

### How Express Works
In traditional data-driven websites:
1. Web app waits for HTTP requests
2. Determines action based on URL pattern and POST/GET data
3. Reads/writes from database or performs tasks
4. Returns response (often dynamic HTML page)

Express provides methods to:
- Specify functions for particular HTTP verbs (GET, POST, etc.) and URL patterns (Routes)
- Specify template/view engine, template file locations, and which template to use

## Basic Server Setup

### Step-by-Step Setup
1. Create directory and navigate:
   ```bash
   $ mkdir myapp
   $ cd myapp
   ```

2. Create package.json:
   ```bash
   $ npm init
   ```
   - Accept defaults
   - Set entry point to app.js (or index.js)

3. Install Express:
   ```bash
   $ npm install express          # Save to dependencies
   $ npm install express --no-save # Temporary install
   ```

### Hello World Example
```javascript
const express = require('express');
const app = express();
const port = 3000;

app.get('/', function(req, res) {
    res.send('Hello World!')
});

app.listen(port, function() {
    console.log(`Example app listening on port ${port}!`)
});
```

**Explanation:**
- First two lines import Express and create application object
- `app.get()` defines route for HTTP GET requests to `/`
- Callback receives request (`req`) and response (`res`) objects
- `res.send()` returns "Hello World!"
- Server starts on port 3000

## Modules in Node.js/Express

### What are Modules?
- JavaScript libraries/files imported via `require()`
- Express itself is a module
- Middleware and database libraries are modules

### Creating and Using Modules
**Exporting functions:**
```javascript
// square.js
exports.area = function(width) { return width * width; };
exports.perimeter = function(width) { return 4 * width; };
```

**Importing and using:**
```javascript
const square = require('./square');
console.log('The area with width 4 is ' + square.area(4));
```

**Exporting complete object:**
```javascript
module.exports = {
    area: function(width) { return width * width; },
    perimeter: function(width) { return 4 * width; }
};
```

**Note about exports:**
- `exports` is a shortcut to `module.exports`
- `exports` holds reference to same object as `module.exports`
- Assigning new value to `exports` breaks this binding

## Asynchronous Programming in Node.js/Express

### Synchronous vs Asynchronous APIs

**Synchronous:** Operations complete in order
```javascript
console.log('First');
console.log('Second');  // Prints "First", then "Second"
```

**Asynchronous:** API starts operation and returns immediately
```javascript
setTimeout(function() { 
    console.log('First'); 
}, 3000);
console.log('Second');  // Prints "Second", then "First"
```

### Why Async is Crucial in Node.js
- Node.js is single-threaded and event-driven
- All requests run on same thread (not separate processes)
- Efficient for speed and resources
- Long synchronous operations block ALL requests

### Callback Pattern and Issues
**Callback Hell:** Nested callbacks from dependent async operations
```javascript
asyncFunc1(function(err, result1) {
    asyncFunc2(result1, function(err, result2) {
        asyncFunc3(result2, function(err, result3) {
            // More nesting...
        });
    });
});
```

**Solutions:**
- Good coding practices (see http://callbackhell.com/)
- Use `async` module
- Use ES6 Promises

**Error-First Callbacks Convention:**
- First argument is error value
- Subsequent arguments contain success data
- Example: `function(err, data) { ... }`

## Route Handlers

### Basic Route Definition
```javascript
app.get('/', function(req, res) {
    res.send('Hello World!');
});
```

**Response Methods:**
- `res.send()` - Send string/HTML
- `res.json()` - Send JSON response
- `res.sendFile()` - Send file
- `res.render()` - Render view template

### HTTP Methods Supported
Express supports all HTTP verbs:
- `get()`, `post()`, `put()`, `delete()`
- `checkout()`, `copy()`, `head()`, `lock()`
- `merge()`, `mkactivity()`, `mkcol()`, `move()`
- `n-search()`, `notify()`, `options()`, `patch()`
- `purge()`, `report()`, `search()`, `subscribe()`
- `trace()`, `unlock()`, `unsubscribe()`

### Special Method: app.all()
Responds to ANY HTTP method for a path:
```javascript
app.all('/secret', function(req, res, next) {
    console.log('Accessing secret section...');
    next();
});
```

## Router Object for Route Organization

### Creating a Router Module
```javascript
// wiki.js
const express = require('express');
const router = express.Router();

router.get('/', function(req, res) {
    res.send('Wiki home page');
});

router.get('/about', function(req, res) {
    res.send('About this wiki');
});

module.exports = router;
```

### Using Router in Main App
```javascript
const wiki = require('./wiki.js');
app.use('/wiki', wiki);
// Routes now at /wiki/ and /wiki/about
```

## Middleware

### What is Middleware?
- Encapsulates functionality operating on HTTP requests
- Function with three arguments: `req`, `res`, `next`
- Executes in a pipeline (order matters)

### How Middleware Works
**Pipeline Analogy:**
- Like water through pipes with gauges and valves
- Order matters (gauge before/after valve has different effect)
- Middleware inserted with `app.use()`

**Key Points:**
- Middleware performs operations on request/response
- Calls `next()` to pass to next middleware/route handler
- Can end cycle (send response) or pass control
- If doesn't end cycle, MUST call `next()`

### Middleware Execution in Express 5.0+
- Invoked in linked order
- Last middleware often "catch all" 404 handler
- Request terminates if middleware doesn't call `next()`

### Middleware vs Route Handlers
- Route handlers are middleware for specific HTTP verbs
- Middleware can handle all verbs (like `app.all()`)
- Route handlers require path parameter
- Middleware path is optional (defaults to `/*`)

**Callback Parameters:**
- 2 params: `req`, `res` (must send response)
- 3 params: `req`, `res`, `next` (can pass control)
- 4 params: `error`, `req`, `res`, `next` (error-handling)

### Important Rules
1. If you don't call `next()`, pipeline terminates
2. If terminating, should send response (`res.send()`, etc.)
3. If you call `next()`, avoid sending response (will be ignored)
4. Not sending response leaves client hanging (times out)

### Middleware Example
```javascript
app.use(function(req, res, next) {
    console.log('Processing request for "' + req.url + '"');
    next();
});

app.use(function(req, res, next) {
    console.log('Terminating request');
    res.send("Done!");
    // No next() called - request ends here
});

app.use(function(req, res, next) {
    console.log('Never called!');
});
```

## Types of Middleware

### 1. Application-Level Middleware
- Bound to app instance using `app.use()` and `app.METHOD()`
- Runs for all routes in app object

**Examples:**
```javascript
// Runs for every request
app.use((req, res, next) => {
    console.log('Time:', Date.now());
    next();
});

// Runs for /user/:id path
app.use('/user/:id', (req, res, next) => {
    console.log('Request Type:', req.method);
    next();
});

// Route handler (also middleware)
app.get('/user/:id', (req, res, next) => {
    res.send('USER');
});
```

**Series of Middleware:**
```javascript
app.use('/user/:id', 
    (req, res, next) => {
        console.log('Request URL:', req.originalUrl);
        next();
    },
    (req, res, next) => {
        console.log('Request Type:', req.method);
        next();
    }
);
```

**Skipping with next('route'):**
```javascript
app.get('/user/:id', (req, res, next) => {
    if (req.params.id === '0') next('route'); // Skip to next route
    else next();
}, (req, res, next) => {
    res.send('regular');
});

app.get('/user/:id', (req, res, next) => {
    res.send('special'); // Called when id is '0'
});
```

### 2. Router-Level Middleware
- Bound to `express.Router()` instance
- Works like app-level middleware
- Use `router.use()` and `router.METHOD()`

**Example:**
```javascript
const express = require('express');
const app = express();
const router = express.Router();

router.use((req, res, next) => {
    console.log("Time:", Date.now());
    next();
});

router.use('/user/:id', (req, res, next) => {
    console.log("Request URL:", req.originalUrl);
    next();
}, (req, res, next) => {
    console.log("Request Type:", req.method);
    next();
});

router.get('/user/:id', (req, res, next) => {
    if (req.params.id === '0') next('route');
    else next();
}, (req, res, next) => {
    res.render('regular');
});

app.use('/', router);
```

**Skipping with next('router'):**
```javascript
router.use((req, res, next) => {
    if (!req.headers['x-auth']) return next('router'); // Exit router
    next();
});
router.get('/user/:id', (req, res) => {
    res.send('hello, user!');
});

app.use('/admin', router, (req, res) => {
    res.sendStatus(401); // Called when no x-auth header
});
```

### 3. Built-in Middleware
Bundled with Express (no installation needed):

| Middleware | Description |
|------------|-------------|
| `express.static` | Serves static assets (images, CSS, JS) |
| `express.json` | Parses JSON payloads |
| `express.urlencoded` | Parses URL-encoded payloads |
| `express.raw` | Parses payloads into Buffer (`req.body`) |
| `express.text` | Parses payloads into string |

#### Using express.static
```javascript
const express = require('express');
const app = express();

// Serve files from 'images' and 'htmls' directories
app.use(express.static('images'));
app.use(express.static('htmls'));

app.get('/product', (req, res) => {
    res.sendFile("productsample.html");
});
```

**File lookup order:** Express checks directories in order they're added. In example above, checks `images` first, then `htmls`.

**HTML Example:**
```html
<html>
<body>
    <h2>My sample product page</h2>
    <img src="sample.jpg" alt="sample"> <!-- Looks in static dirs -->
</body>
</html>
```

#### Using express.json
```javascript
const express = require('express');
const app = express();

// Attach to specific route with size limit
app.use('/products', express.json({ limit: 100 }));

app.post('/products', (req, res) => {
    const name = req.body.name;
    const brand = req.body.brand;
    const category = req.body.category;
    console.log(name + " " + brand + " " + category);
    res.json({ success: true });
});
// Sample JSON: {"name":"furniture", "brand":"century", "price":1067.67}
```

#### Using express.urlencoded
```javascript
app.use(express.urlencoded({ extended: false }));
// Then access form data via req.body.fieldName
```

### 4. Third-Party Middleware
Install via npm, then load in app.

**Morgan (Logging):**
```bash
npm install morgan
```
```javascript
const express = require('express');
const morgan = require('morgan');
const app = express();
app.use(morgan('tiny'));
```

**Cookie-Parser:**
```bash
npm install cookie-parser
```
```javascript
const express = require('express');
const cookieParser = require('cookie-parser');
const app = express();
app.use(cookieParser());
```

## Error Handling Middleware

### Default Error Handler
- Express has built-in error handler
- Added at end of middleware stack
- Can override with custom handlers

### Custom Error Handler Signature
```javascript
function customErrorHandler(error, request, response, next) {
    // Error handling logic
}
```

**Important:**
- Must have FOUR arguments
- First argument is error object
- Even if not using `next`, must include it in signature

### Creating Error Handlers
```javascript
const errorLogger = (error, req, res, next) => {
    console.log('error ' + error.message);
    next(error); // Pass to next error handler
};

const errorResponse = (error, req, res, next) => {
    res.header("Content-Type", 'application/json');
    const status = error.status || 400;
    res.status(status).send(error.message);
};

const invalidPathHandler = (req, res, next) => {
    res.status(404).send('Invalid path');
};
```

### Triggering Error Handlers
**Throwing errors:**
```javascript
app.get('/productswitherror', (req, res) => {
    let error = new Error('Processing error at ' + req.url);
    error.statusCode = 400;
    throw error; // Will be caught by error handlers
});
```

**Using next() with error:**
```javascript
app.get('/somepath', (req, res, next) => {
    const err = new Error('Something went wrong');
    next(err); // Pass to error handler
});
```

### Complete Error Handling Example
```javascript
// Error handling middleware functions
const errorLogger = (error, req, res, next) => {
    console.log('error ' + error.message);
    next(error);
};

const errorResponse = (error, req, res, next) => {
    res.header("Content-Type", 'application/json');
    const status = error.status || 400;
    res.status(status).send(error.message);
};

const invalidPathHandler = (req, res, next) => {
    res.status(404).send('invalid path');
};

// Routes
app.get('/', (req, res) => {
    res.send('Home page');
});

app.get('/productswitherror', (req, res) => {
    let error = new Error('processing error in request');
    error.statusCode = 400;
    throw error;
});

// Attach error handlers (AFTER routes)
app.use(errorLogger);
app.use(errorResponse);
app.use(invalidPathHandler);
```

**How it works:**
1. `/productswitherror` throws error
2. `errorLogger` logs error message
3. `errorResponse` sends error to client
4. Invalid paths trigger `invalidPathHandler`

## Complex Example Demonstrating Middleware Flow
```javascript
var app = require('express')();

app.use(function(req, res, next) {
    console.log('\n\nALLWAYS');
    next();
});

app.get('/a', function(req, res) {
    console.log('/a: route terminated');
    res.send('a');
});

app.get('/a', function(req, res) {
    console.log('/a: never called');
});

app.get('/b', function(req, res, next) {
    console.log('/b: route not terminated');
    next();
});

app.use(function(req, res, next) {
    console.log('SOMETIMES');
    next();
});

app.get('/b', function(req, res, next) {
    console.log('/b (part 2): error thrown');
    throw new Error('b failed');
});

app.use('/b', function(err, req, res, next) {
    console.log('/b error detected and passed on');
    next(err);
});

app.get('/c', function(err, req) {
    console.log('/c: error thrown');
    throw new Error('c failed');
});

app.use('/c', function(err, req, res, next) {
    console.log('/c: error detected but not passed on');
    next();
});

app.use(function(err, req, res, next) {
    console.log('unhandled error detected: ' + err.message);
    res.send('500 - server error');
});

app.use(function(req, res) {
    console.log('route not handled');
    res.send('404 - not found');
});

app.listen(3000, function() {
    console.log('listening on 3000');
});
```

## Key Concepts Summary

### 1. Middleware Pipeline
- Order of execution matters
- Each middleware can:
  - Process request/response
  - Call `next()` to continue
  - Send response and end cycle
  - Throw/pass errors

### 2. Error Handling
- Special middleware with 4 parameters
- Attach after route definitions
- Use `next(error)` or `throw error` to trigger
- Can have multiple error handlers for different tasks

### 3. Route Organization
- Use `express.Router()` for related routes
- Group by feature/prefix (e.g., `/wiki/*`)
- Export router and mount with `app.use()`

### 4. Static Files
- Use `express.static()` middleware
- Can have multiple static directories
- File lookup follows directory order
- Directory name not in URL

### 5. Request Body Parsing
- `express.json()` for JSON payloads
- `express.urlencoded()` for form data
- Configure limits and options
- Access via `req.body`

### 6. Best Practices
1. Organize code with modules
2. Use async patterns to avoid blocking
3. Implement proper error handling
4. Use middleware for cross-cutting concerns
5. Structure routes logically with Router
6. Handle all possible errors and invalid paths